# üõë üëÆ üõë Make sure your have permission first. 
Is there a rule book? Does the appropriate authority figure approve? And in my opinion, if you physically open an organization's computer, that's a whole other level right there. I'd double check before doing that, even if you already got a green light on the software side. **I do not warrant that all troubleshooting tips are legal in every jursidiction and for every firmware and hardware. Conformance to EULAs and applicable laws, regulations, etc. are on you.**

# üõë Safety first
**Following these instructions are at your own risk.**
It is advisable to backup your data before beginning, if applicable. 
If you physically open a machine to do work, stay electrically neutral with the machine to avoid damage caused by static discharge. For example, touch a metal part of the case before touching anything with a chip. Or even better, use an anti-static wrist strap.  
It might even be worth keeping loose internals in anti-static bags and/or on an anti-static mat instead of just setting them down. My first experience with a Raspberry Pi was that it died very quickly after acquisition. Probably due to static discharge. You have been advised.
I have also read that it's advisable to keep the machine plugged-in while working on it if you can help it, just to keep the thing grounded. I have also heard advice to make sure you do unplug it. Looks like it's your call.

# üêîü•öüîÅ
You have to break the chicken and egg problem at some point.
1. Typically, you perform imaging and cloning with a bootable flash drive. Looking at EFI and BIOS standards, you would think that you would need a computer to which you have admin/root privileges to make said drive. (And permission to insert a flash drive at all.)
2. Ideally, you image a machine before modifying it so you can put it back.
3. Often, the easiest way to get admin/root privileges on your own is to install Linux fresh from a USB drive, or at least use root privileges from the live environment.

So what comes first, a machine to which you have admin/root privileges to make bootable media, or bootable media to get admin/root privileges? If you think you can just use your personal machine to make the media, think again. You may want to be able to say, "these flash drives were only ever connected to DevNet machines, never to my personal machine."

## Options
* __*I went with #1.*__ This means I did not test the other options. You have been warned.  
* __*You might not even want to boot a computer until you image it.*__ This way, you know you can put it back as it was. It may be "spring loaded" to start installing stuff, configure itself, and/or make record that it has been booted, once booted.
  * From a software perspective, the surefire method is to leave it off, remove the SSD/HDD, and image it with another computer, likely using an enclosure. Or with an enclosure and the same computer, but don't plug it in until booted into something else.  
    * Whether you have permission to open the machine up, whether you are comfortable doing so, and/or whether there are one or more tamper-evident devices in place to show that the computer has been opened/had the drive removed, is a different story. 
  * A riskier approach (software-wise) is to go right into firmware settings upon boot-up and enable USB booting, and, if necessary, disable "secure boot" (more on this later), then reboot into Clonezilla to image. This is riskier because the firmware might not "catch" that you're pressing the key to go into settings and instead boot the internal drive. You also might not know what the key is yet for sure.

1. If your org already has a way to re-image computers, and you have a Windows machine, it is probably acceptable to begin reconfiguring your first machine without imaging it beforehand. This limits your non-undoable (by you) machines to just one. Log out, hold shift, and click restart. From the recovery menu, you can reinstall Windows. Eventually, you can make an admin account on that machine from which you can make bootable media; see `WindowsSetup.md` for details on making that admin account.
    * While I only made bootable flash drives with Ventoy from within Windows, if you cannot readily enable USB booting, you can set up WSL within Windows (once you have an admin account), put an internal drive in an encloure, "bare mount" the enclosed drive into the WSL environment, and install Linux, clone, or image from there, then put the drive into a machine and boot it.
2. Obviously, you can purchase a computer, dedicate it to your DevNet, and use it to break your "chicken and egg" situation. For example, you may be able to image each pre-existing computer without booting their drives by removing these, putting each in an enclosure, and imaging them from this machine using Clonezilla. And/or install Linux to such a drive from this machine. And/or create your initial boot media from this machine. Or even flash the EFI ROM chip of another computer from this computer to clear the EFI password.
    * While you might not run Clonezilla on a Raspberry Pi, we can still break the chicken and egg problem with one fairly easily, and it's a lot cheaper than even a Chromebook. The Raspberry Pi Zero 2 W CanaKit is $55.95 at time of writing. It comes with a bootable SD card (bootable on the Pi, that is), but you have to supply the keyboard, mouse, and monitor. Good news: that SD card comes bootable into Linux, so you'll have all the basic, standard, open-source methods available to you for formatting both filesystems and partition schemes. Specifically, it comes with Raspberry Pi OS. You can use it to make Clonezilla boot media for the org machines, but, unlike the next option (#3), you will have an *even higher chance* of being able to make it work, as you will have root permissions. So even if the EFI firmware on the org machines is a real stickler and requires you to mark a partition as an EFI system partition on a GPT-schemed disk for it to be bootable, you have the root permissions to make it so.
    * Alternatively, you can directly clone/image from the Pi. I don't particulary recommend this as I'm not confident in the Pi Zero's ability to handle compressing and decompressing volume images with it's limited CPU and RAM, at least not quickly. If this is still your choice, we can knock out two issues with one solution. Issue one: Clonezilla does not come pre-made for ARM architectures, and the Pi has an ARM architecture. Issue two: how many gigabytes can the Pi's exposed USB port faithfully copy before it corrupts a byte? You see, during one project, I was challenged by at least one USB port that would occationally corrupt data in transit. Admittly, my experience was not with a Pi, but it makes me question and demand ***hash verification*** where I do seriously question. Solution: string together `dd`, `pv` (pipe viewer, to see progress), and `mksquashfs` to save an image of a whole drive inside a Squash filesystem, or individual volumes, each into their own SquashFS file. Using SquashFS like this provides compression on-the-fly, meaning the image is compressed as it is being made (read from disk). You can then mount these SquashFS files and hash the contained image files with `openssl md5` without having to decompress a whole image first. In contrast, Clonezilla does not compress with something intended to be mounted as a filesystem. While there is `fuze-zip`, which should be able to mount zip files produced by Clonezilla (you'd have to stick with the default zip format in the wizard), I did not go with that method. I don't remember for sure why I didn't use `fuze-zip`: maybe it just didn't work; maybe Clonezilla's zip option didn't take advantage of more than one CPU core -- maybe both. *I have used the `dd` + `pv` + `mksquashfs` method.* And you can pipe `dd` into `pv` and on into `openssl md5` to directly hash the block device you just imaged. You're hoping for matching hashes. Know the image(s) will possibly be larger than what Clonezilla would produce due to deleted data in free space, as you would be using a lower-level command unaware of how to interpret filesystems. Of course, you'd need your own command to clone with these images as well. You'll likely need to install `pv` and `squashfs-tools` (includes `mksquashfs`) first, whereas `dd` should already be installed.
        * In the case of cloning a Linux machine that uses LUKS, open (decrypt) the LUKS volume first (which creates a block device, a special file, distinct from that of the LUKS volume itself) and then image each filesystem device intended for a system path such as `/`, `/boot`, and `/home` (most or all should be "in" the LUKS volume). By "system path", I mean "a permanent part of your file structure", as opposed to a flash drive or something like that. You may have more or less such filesystem devices than the three just listed. For simplicity, I assume no swap volume. For each, save the image into a Squash filesystem on-the-fly. By not imaging the LUKS volume itself, we allow each "cloned" machine to have its own master key and associated password(s). In the simple case of a non-encrypted `/boot` parition and a LUKS partition directly containing a volume for `/`, you'd make 2 SquashFS files: one for `/boot` and one for `/`. On the target drive, you'd make sure there's a partition for `/boot` and a parition set up with LUKS and a password. You'd open the LUKS volume and write the `/` image to the resulting block device (not the LUKS block device itself!). And you'd write the `/boot` image to its intended destination partition. In the event you wrote a smaller image to a larger volume, grow the filesystem to match the volume it is now in. (Obviously, you can't write a larger image to a smaller volume, though, as a work-around, you may be able to mount the image and use `rsync` to copy files over, preserving their attributes.) Then you'd mount the cloned filesystems and edit the UUID of the LUKS volume in `[mount point]/etc/crypttab` to match the target drive's LUKS volume. Next, in the case of Fedora, edit the kernel paramerer line in `[other mount point]/boot/grub.cfg` to use that UUID for the LUKS volume (even if the file says not to edit it; you're just getting it started; automatic things can overwrite that file later). With Ubuntu and related distros, you'd have to rebuild the initramfs. (Where Ubuntu puts config files in the initramfs, Fedora prefers kernel parameters, virtually eliminating the need to manually rebuild the initramfs.) If you want more than one encrypted filesystem, like for `/` and `/home`, you could have an LVM container in the LUKS partition and then, reusing the example, have those two filesystem devices for `/` and `/home` in the LVM container. Having both LUKS and LVM is actually the norm. In that case, you'd have one more layer to recreate on the target drive before you could clone the filesystems over that you wish to be encrypted. Or, you could image the LVM container itself and skip some manual work: the cloning process would create the LVM container *and* the volumes therein in that case. But that method would likely write to far more blocks of the SSD/HDD than necessary. And you may need to grow the LVM container. So the manual tedium might actually save you some time. 
        * Long story short, make sure the image(s) and their source special files (e.g. `/dev/mapper/home`, `/dev/mapper/root`, or whatever you've named them) have matching hashes. It's a good idea to keep those hashes. Delete any corrupted copies.
    * *See the next bullet for more details on creating Clonezilla boot media and how to get around disabled USB booting with an SD card.*
3. You may be able to copy files to an SD card or USB drive and *poof*, it's bootable. Key phrase "may be".
    * As I have seen with Macbooks (and according to the Clonezilla documentation, presumably with many computers), if your machine's firmware is more lenient than the bare EFI standard, you may be able to make a flash drive or SD card bootable just by putting the right files on it and in the right places, no admin privileges needed, provided the flash drive/SD card is FAT-formatted (most come from the factory that way).
    * But is the computer that you're preparing the flash drive with the same computer you'll be imaging as a backup so you can undo your work? If so, the downside here is that you are imaging a machine ***after*** you've both booted it and have plugged a flash drive into it. In this case, when you restore with that image, at least with Windows, there's record that a flash drive has been inserted into it (unless you remove this record), and therefore may be in a quarantined state. There could even be record if you insert an SD card. Now, if you used a built-in SD card reader, there'd be no record of a new USB device as the built-in SD card reader already is the USB device, but, the media insertion event may still have induced a quarantined state.
    * ***The answer to the previous bullet may be your local library.*** If you bring a brand-new flash drive, still in its unopened packaging to your local library and ask nicely, you may be able to use a library machine, without admin/root privileges, to make the drive bootable.
    * Alternatively, in the case you cannot readily enable USB booting, you can use an SD card and, possibibly, an external USB SD card reader. Then you can use an SD to SATA adapter or an SD to PCI-E adapter to boot the SD card as though it were an internal drive. There's adapters from SD to standard SATA and to mSATA (mini SATA). And you could chain an SD to standard SATA adapter with a SATA to micro SATA adapter if need be. Electrical tape may be warranted in certain places to keep the adapter(s) from shorting against a bracket, frame, etc. If you're going the library route, I'd take the SD card and USB reader to the library, both still new in their packaging.
    * Back to the topic of preparing boot media without admin/root privileges: if your firmware is so accommodating, you can simply extract the Clonezilla zip (not the iso) directly into the root level of your flash drive or SD card, and it's bootable into Clonezilla. Since Clonezilla is a Linux environment, you can exit the Clonezilla wizard and use the Linux terminal. The enabling factor here is that EFI is advanced enough to load a file off a FAT-formatted disk into memory and execute it as a bootloader, avoiding the need to write to the boot sector as was the case in the BIOS days, which definitely required elevated privileges.
        * A potential obstacle is that, according to the EFI standard, the partition needs to be marked as an EFI system partition, and to mark it so, you need elevated privileges. However, I have seen Macbooks ignore this "requirement" and boot flash drives with no partition marked as the EFI system partition. Clonezilla documentation implies that this behavior is common in general, not just with Macs.
        * Another potential obstacle is whether your firmware requires the SD card or flash drive to have a particular partition scheme. The strict standard expects a GPT scheme. Given that most EFI firmwares are already lenient enough to ignore the EFI system partition flag requirement, I would expect either the MBR scheme or GPT scheme to work. But I would not be surprised if even a lenient firmware ignored "superfloppies." A superfloppy is a storage device where its entire block range has been formatted to a filesystem, without a partition table at all, as was the convention with floppy disks. You see, MBR-schemed disks can plea a backwards compatibility case with EFI/GPT; GPT even has a mock MBR table for backwards compatibility. But what business does something like a floppy disk have in booting a modern, EFI machine?
        * For the above reason, if you are chancing an SD card to have a partition scheme (or lack thereof) to the liking of your target firmware (and you don't have the admin/root privileges to change the scheme or lack thereof of the SD card), I'd say your best bet is to buy an SD card off Amazon that's "verified for Garmin devices". Then it has a good chance of having an MBR scheme, which, in my opinion, improves your chances over an SD card that might come from the factory as a superfloppy. If for whatever reason it doesn't work, and you have a digital camera, formatting it with the camera might make it to the firmware's liking. There's a screenshot of the MiniTool Partition Wizard under "Step 4: Finally" in [this how-to](https://www.partitionwizard.com/partitionmagic/garmin-dash-cam-sd-card-format.html) that reveals that at least one SD card for a Garmin device is MBR-formatted, hence my "verified for Garmin devices" theory. To have even higher chance of success, I would also buy one that is not "verified for Garmin" and is a different brand. That way, if you are unlucky enough to have a firmware that dislikes MBR-schemed disks, you increase your chances of getting one that comes other-than-MBR-schemed (superfloppy or GPT). Maybe you have a really weird firmware that says "no" to MBR and "yes" to superfloppy. Unlikely, but yet disproven. 
        * Afterwards, to boot something other than Clonezilla off the flash drive or SD card, you can either:
          * Edit the existing bootloader config file (probably `syslinux.cfg`) to boot an iso you place on the storage device (Yes, Linux can boot itself out of an iso without you first extracting all the files! You just have to give it the right kernel parameters, etc.), or
          * Make sure you download the *alternative* stable Clonezilla zip (Ubuntu-based), boot it, exit the wizard to a Linux terminal, connect to the Internet, and install `usb-creator-common`. You can use that command-line tool to make another flash drive/SD card bootable into a Linux live environment (installer) of your choice of distro.  
4. You may be able to burn a bootable iso to a CD or DVD. However, you'll probably need to buy a USB optical drive to boot it; it's been years since I've seen a new laptop come with an optical drive built-in. One approach is to nicely ask your local library if you may burn the iso with one of their computers, which hopefully has a built-in burner. You may also be able to use an existing org machine to so so, but, you will likely need to buy a USB optical drive that supports burning for this. ***By default,*** last I checked, according to what I've found on the Internet, you do not need admin privileges in Windows to burn an iso. However, your administrator may have set Windows to disallow burning.
5. You could purchase a flash drive or CD/DVD that comes bootable into a Linux distro and make subsequent bootable drives from that. You'll want to be sure you get one from a very reputable source. Note that getting a bootabe SD card for a Raspberry Pi is not going to work for most laptops/desktops as the Pi has ARM architecture, while most laptops/desktops have x86_64 architecture.

I have seen claims online that you can make bootable media without admin rights in Windows, such as by using Rufus, which is a "portable app" and therefore does not need to be installed, which is the basis of these claims that you don't need admin rights. But in my experience, all these bootable media tools reformat the USB drive, which takes elevated privileges. They would need to automate something like what I detail in Option #3, which, again, is not guaranteed to be bootable on all systems. 

# Once you have a "chicken"... üêî ü†Æ ü•ö
Ventoy is a great utility for creating bootable flash drives/SD cards. The big deal is that you don't have to edit a bootloader config file. Just put the isos on your flash drive/SD card, and Ventoy finds them, making this drag-and-drop! The Ventoy tool to make bootable media has both Windows and Linux versions.  

Being up-front, I have only used Ventoy with secure boot disabled. If you are unable/unwilling to disable secure boot, for example, if you don't have the EFI password to do so and you've already tried common default passwords (and maybe tried measures beyond that), you may or may not have an issue with Ventoy. As of Novemeber 5th, 2025, I see that Ventoy still has a ticket open about this. It's worth asking: if you can't boot your flash drive/SD card, is it a secure boot problem with Ventoy, or is USB booting just disabled? If the former, you can use Fedora Media Writer to make a flash drive/SD card bootable into the equivalent of just one Fedora Live ISO, which I would then expect to work, as Fedora is ahead of Ventoy in supporting secure boot, which is honestly a political problem moreso than a technical problem. If Ventoy's shim hadn't been blacklisted, we wouldn't be in this situation, as I understand it (shims are explained in the advanced portion of this document). If USB booting is disabled, the previous section lays out a work-around using an SD card. Anyhow, by and large, at time of writing, this how-to will assume we're going with Ventoy. I'm happy to test and document alternatives once I'm in a position to do so. But let me finally document what I have done first. Though I will say, after using Fedora Media Writer, it is possible to edit the bootloader config file to give menu options to boot other isos you place on the flash drive/SD card. It's just a manual process that, in my experience, takes trial and error. Ventoy is automatic; just drag-and-drop. Once you're past EFI and into Grub, you're past secure boot and USB booting hurdles; Grub can boot about anything.

Download the below (or whatever distros/spins you choose, however, instructions may be specific to the linked choices).  
*For isos, you usually want the "Intel x86_64"/"AMD64" Live ISO option. If a different case applies, you are very likely to already know.*
1. [Ventoy](https://www.ventoy.net/en/download.html)
2. [Clonezilla iso](https://clonezilla.org/downloads.php)
    * If you plan on exiting the Clonezilla wizard to use this as a USB-bootable Linux environment, albeit a command-line one, you may want the Ubuntu-based "alternative," as this makes installing Ubuntu packages an option, though packages are best installed with an Internet connection.
3. [Fedora server iso](https://www.fedoraproject.org/server/download)
4. [Fedora KDE (workstation) iso](https://fedoraproject.org/kde/download)

Then install Ventoy and use it to make your flash drive/SD card bootable into one of the isos. Next, just copy the other isos onto the device. üéâ

# Firmware & Booting the flash drive/SD card
In summary,
01. Deal with any existing EFI password prompt or go around the prompt. Some people may still refer to the password as the "BIOS password".
02. Ideally, enable USB booting.
03. Ideally, disable secure boot.
04. Check through all EFI settings while you're there. Maybe enable "quick/fast boot". Maybe make the internal drive first in the boot order.
05. Highly encouraged: Make sure hardware virtualization is turned on. What if you need a virtual machine to play an old game?
    * Or, maybe you want to give back to Clonezilla, Ventoy, the Linux kernel, etc. You'd want hardware virtualization support to test your changes in a VM.
06. Set/reset the EFI password if it was not set or was some default. ***Securely record this password.***
07. Sign a tamper-evident seal and let the ink dry, or at least as much as it will in minute or two. Be careful not to smear your signature.
08. Adhere the tamper-evident seal across the juncture where the cover of the machine (likely a laptop) and main case body meet.
09. Cover the seal with clear tape to protect the signature.
10. Save your changes, restart (if needed), and boot into the flash drive (ideally)
11. Image, clone, install Linux, or do whatever you planned on doing from the USB live environment
12. "Optionally" disable USB booting once you're done doing USB booting. Maybe ensure PXE booting, CD/DVD booting, and, if present, floppy booting, are disabled, too.
    * If your users will not be using a read-only flash drive or something similar to boot the machine every time, this is not so optional. Otherwise, your unencrypted boot volume could be compromised if someone boots your machine into a flash drive, PXE environment, CD, floppy, or what have you.
13. Optionally, re-enable secure boot once you're done using Ventoy.

There's typically 2 special keys on your keyboard here. One to go into EFI settings and one to bring up a boot menu to let you choose to boot into your flash drive (or maybe a CD/DVD, etc.).  
You might only need the key into the boot menu if the menu gives the option of going into settings. If you're pampered, after you save your changes to the EFI settings, it might give you the option to boot into your flash drive/SD card right then and there, no restart needed.

In my experience with Dells, F2 goes into settings and F12 brings up the boot menu.
In my much more limited experience with HPs, *either* Esc or F10 goes into settings and F9 goes into the boot menu. To clarify, in the specific case of the HP Probook I tried, both Esc and F10 work to tell the machine to go into settings, but I don't know if I would try both in one boot.  

Infamously, there's finesse required in getting the firmware to go into settings or the boot menu. Do you repeatedly press the key right after seeing the power button light up? Do you hold the key down instead? Start holding before or after you see the power button light up?  
In the old PS/2 days, I remember the need to press the special key *exactly once*. Multiple presses could (or maybe even definitely would) overwhelm it.  
There's even a freak chance that a laptop's built-in keyboard is broken, in which case the easiest workaround is to connect a USB keyboard.

In my experience with Dells and HPs, spamming the special key worked (except for the old PS/2 days). Whereas with Macs, I recall holding the key for quite a while being the move.

You may be greeted with a password prompt to get into EFI settings (or maybe even to get to the boot menu). I would try sensibly plausible defaults like "admin", "password", "root", "administrator", "default", "0000", and "1234", as well as just hitting enter when no text is in the field. Failing that, Google if your brand and/or specific model has a known default.

# Advanced secure boot troubleshooting (with or without a password)
Background:
* A "payload" is very often a bootloader that then actually boots your OS. (Though I suppose it is possible for secure boot to directly boot your OS kernel, in which case the kernel would be the payload.)
* A payload can be cryptographically signed with a "certificate". These certificates have expiration dates.
* Secure boot only boots payloads signed by a certificate that it trusts, either directly, or because the certificate is itself signed by another certificate that secure boot trusts.
* The signatures are also timestamped (i.e., have record of when the payload was signed with a certificate, independent of the certificate's expiration date).
* Importantly, secure boot honors payloads signed with expired certificates, provided the timestamp predates expiration...as long as the firmware trusts the certificate.
* Trust can be revoked if the firmware has a certificate blacklisted, even if it would otherwise trust the certificate.
* **A shim is a middle-man bootloader that exists purely to satiate secure boot**: the shim is signed, secure boot (hopefully) boots the shim, then the shim immediately loads your actual bootloader.
* Finally, ***Windows updates can include firmware updates.*** This means that updating Windows can blacklist a shim that was peviously trusted, or, trust a newly-signed shim that previously was not trusted. *Updates are a double-edged sword.* 

Though I don't expect it, if even Fedora (not Ventoy) is thwarted by secure boot (whether an "installation" of Fedora or a flash drive/SD card prepared by Fedora Media Writer), you may be able to solve the problem by
1. Swapping in an old shim that your firmware still trusts (maybe Fedora's current shim is signed with a new certificate your old-state firmware doesn't know about and therefore does not trust). Or,
    * (If this does work, there technically is the possibility that updating your firmware would blacklist your shim's signing certificate, causing this to no longer work.
      I wouldn't worry too much about this, because I have enough faith in the Fedora community. I doubt they'd let this happen without updating their shim beforehand, though you may have to manually undo what you manually did.)
    * Also, because the shim is just a middle-man, you get to enjoy having the latest version of your actual bootloader. 
2. Updating your machine's firmware to get (and trust) new certificates, in hopes that the update will cause your firmware to trust the cert used to sign Fedora's current shim.
    * The risk is if the update adds your shim's signature to the firmware's blacklist. Then our strategy backfires. 
3. While it is possible to add a certificate to your firmware's trusted list, I have my doubts you'd be able to do so without the EFI password. But, hey, maybe your firmware gives you the option to trust the cert right there when you try to boot the payload.

A fallback may be to use WSL instead of installing Linux.

# Other advanced EFI troubleshooting (with or without a password)
Honestly, I'm balancing on the edge of project scope here, but I didn't want to leave you with nothing. So here's some leads for your own further investigation.

If you've gotten this far, and your organizational sys admins are unable or unwilling to assist, it is at this point that you should ask if you and your org are comfortable with you physically opening these machines or not.
I remember a time when motherboards had jumper pins on them to let you clear the BIOS password. Those days may be behind us, but Google anyways to see if your model has such a pin, if you are getting this desperate. More commonly these days, clearing the EFI password, when designed to allow it, is done by turning off the machine, removing the little watch battery, as well as the main battery if it's a laptop, and disconnecting from power. I've read to keep disconnected from power, to include the absence of the batteries, for 20 seconds and I've read to do so for at least 5 minutes ü§∑. After that, put it back together and try again.

Reminder that we're in territory *that I have not tested.*   

## Summary
1. Can you set EFI settings from a shell *without* the EFI password?
    * Briefly describes how to acquire and boot into a UEFI shell and points you in the general direction from there.
2. Clear password with or without a chip programmer (i.e., a chip clip or breadboard device)
    * Pros and cons of either method
    * If your're really lucky, you can replace the EFI firmware entirely with the open source Coreboot.

## UEFI Shell
Before falling into the mentality that you must clear the EFI password, can you just boot into a UEFI shell and change the setting(s) from there? Again, most likely to disable secure boot, enable USB booting, and maybe to enable virtualization.

### What is a UEFI Shell?
The UEFI specification defines [what a UEFI shell is and what it should do][shell-spec]. It's somewhat like Bash, but, for starters, there's no underlying operating system. You're running "bare metal". Basically, it's geared toward firmware-level tasks like setting EFI settings, getting hardware going with in-memory drivers prior to the bootloader and/or OS, and looking at how memory is mapped. While you should expect far fewer commands out-of-the-box than compared to even a minimal commandline Linux environment, a UEFI shell can actually save you work compared to Linux: you would potentially need to compile the Linux kernel yourself and/or set a kernel parameter to have the same functionality. In fact, I wouldn't be surprised if sometimes it'd be *impossible* to do this stuff in Linux due to protected mode.  

While some "fancy" firmwares might have a built-in shell, I would not expect you to be able to boot into the option if you don't have the password. Fortunately, there is at least one free, open source UEFI shell [you can boot][tiano-shell] as a dot-efi file.

### How do I boot a UEFI shell if I have secure boot enabled and/or USB booting is disabled?
A UEFI shell executable is a dot-efi file you can chainload from Grub. Even if you have to use an internal drive in the event USB booting is disabled (or an SD card in an adapter to mimic an internal drive), Fedora Media Writer should place a shim (explained above in "Advanced UEFI troubleshooting") to satiate secure boot to then boot Grub. You can then use the Grub commandline (press "c" when at the menu) or edit the Grub config file to chainload the shell. If PXE booting is enabled, that may also be an option to boot the shell.

### What do I do in the UEFI Shell?
Ideally, just change some variables. The trick is knowing the names of the variables for what you want to change on your particular system and knowing what values to set them to. You may find instructions on the Internet for how to extract at least some of this information from a downloaded firmware updater. Not a lawyer, but the legality there may be questionable as most EULAs have a clause against reverse engineering, decompiling, etc. I suspect you would have to agree to those terms before even being able to download the update. On the other hand, I do wonder if right to repair laws would negate some of that here. Even without analyzing a firmware update, two built-in commands jump out at me for this task: `dmpstore -all` to list all firmware variables and `setvar` to change their values. Deleting a variable can be done with `dmpstore -d`. See the [spec][shell-spec] for details. Heck, you might be able to clear the EFI password with these commands.
* If you have another motherboard of the same model that you are not locked out of (you may wish to purchase a replacement board for this reason) you should be able to basically copy and paste the variables over to your target motherboard. Ideally, put the unlocked board into a machine besides the target machine so you don't have to keep swapping motherboards. Next, update the EFI firmware on your target machine's motherboard and/or the unlocked board to be at the same EFI firmware version, if they aren't already. Then, in the unlocked machine, you can go into the EFI settings as you normally would, set things how you want them, boot into a UEFI shell, and save all variables to a file using `dmpstore`. Then you can take that file into a full OS with a suitable text editor and delete all (if any) lines that change something you don't want changed. I'd double-check that the serial number and MAC address are not altered. I'd also get rid of the GUID arguments (maybe use the `cut` tool from command line), in case the GUIDs are randomly generated. (Whereas I would expect at least variable names to be stable from board to board running the same firmware version.) Then you can boot the target machine into a UEFI shell, use `dmpstore` to backup the existing settings to another file just in case, and then use `dmpstore` to load the settings from the other file.
* [This post][wow] may be good reference material. Reportedly, he extracted a function from a firmware updater that, when ran from the shell, clears the password. More specifically, I believe the updater has a function for putting things back after updating, to include the password -- the function accepting all this stuff in a convoluted data structure. My belief is that by directly calling this function with an empty (or `null`?) data structure causes the password to be cleared. I doubt the updater would have a function just for clearing the password.
    * BTW, in DOS, you could write to `null` in C, since C implements `null` as a pointer to memory address zero. Normally, attempting to write there would cause a segmentation fault. But DOS didn't set protected memory regions, so there wouldn't be a seg fault. As far as UEFI shell, I don't know. 

You can also run other bare-metal executables from a UEFI shell. These usually have a dot-efi file extension. For example, [UEFIToolsPkg][uefitools] gives you back a few of the common unix commands.

[uefitools]: https://github.com/andreiw/UefiToolsPkg

I have not found a tool that really supports dumping and flashing the ROM chip with raw binary files from within a UEFI shell. Yes, there is the built-in command `hexedit`, but you have to know where in memory to edit. Any attempt to directly edit the ROM this way would be up against compression as well, since the ROM holds things in a compressed form.

## Dumping and Flashing
As a little background, the EFI firmware itself is stored on a so-called ROM chip on your motherboard. Despite "ROM" standing for "read-only memory", it can be overwritten through a process called "flashing". This can take minutes. The expectation is that EFI settings are on the same chip. The contents of this chip are accessible, at least during boot-up, at memory addresses, even through the chip is not a part of normal RAM. Flashing is done by writing to these addresses. But much is possible to get in the way. Maybe your operating system does not, at least by default, allow you to write there. Maybe in the process of booting your operating system, the memory controller reroutes those addresses to your normal RAM, making the ROM chip inaccessible for the remainder of the boot cycle (unless you physically connect to the chip with a chip programmer). "Dumping" is the process of saving what's on the ROM chip. It's wise to dump first so you can put it back how it was if what you're trying doesn't work.

The last resort for unlocking a computer's EFI settings (or going around the EFI password prompt) is to "flash" the ROM chip. As mentioned earlier, I could not find tools for doing so within a UEFI shell, so the pointers here use a program called `flashprog` from within Linux.

### With or without a chip programmer?
A chip programmer is a device that attaches to the ROM chip for the purpose of dumping and flashing.

One advantage of using a chip programmer is that you can flash one computer from another. This is great if you're saving a "bricked" machine. It's also great if you are completely and utterly locked out of the target, to the point you can't even boot it into an installation of Linux in which you have root permissions.

Also, a programmer can sometimes break your "chicken and egg" situation: if you can at least boot the thing into Linux where you have root permissions, you can flash the ROM with a programmer attached to your computer *on both ends*. So the computer is flashing itself in that case.

On the other hand, the advantages of not using a chip programmer are that you don't have to buy one and, potentially, can avoid needing to open up the computer case. However, the latter is a bit of a stretch if you are both password-locked-out and do not have USB booting enabled. I could see re-installing Windows with the built-in recovery and then adding an entry in Window's bootloader (bcd) to boot Linux. 

You can attempt booting the target machine into Linux and running `flashprog` to dump and flash the ROM chip without the aide of a chip programmer. Without a chip programmer, you would need to set a kernel parameter, and, worst case, have to custom-compile the kernel, [*more info*][kernel-params]. Unless I was making dedicated boot media for this purpose, I'd hit "e" to edit the boot option for Linux from the Grub boot menu to add the kernel parameter there, as well as to specify the custom-built kernel, if needed. This does not edit your bootloader's config file, so there's no way to forget to put it back when you're done. It only applies your edits to that boot.

There may be hardware differences in how exactly to disable write protection to the ROM chip without using a programmer. (Hopefully, [that earlier link][kernel-params] covers how to do so through custom-compiling the kernel and/or setting a kernel parameter, but I can't expect that to cover all hardware in existence.) An advantage to using a programmer is that you don't have to worry about such things. I also wonder if different hardware maps the ROM to different locations in memory, at least after booting into an OS.

You actually get to use the same software tool with or without a programmer: `flashprog`. You just specify `internal` as the "programmer" to flash the chip of the same computer that is running `flashprog` (no chip programmer) and a different "programmer" if you're using a clip, breadboard, etc. *[Programmers][programmers]*
* `flashprog` is a fork of `flashrom`. A benefit of `flashprog` over `flashrom` is that you cannot, via omission, accidently flash the chip of the computer you are running the tool from when you intend to flash the chip you're connected to from another computer: `flashrom` defaults to `internal`, whereas `flashprog` requires the `programmer` option explicitly.

 My goal would be to avoid soldering and either use a "chip clip"-style programmer or take the no-programmer approach. Some programmers actually have you unsolder the chip, put it on a breadboard or what have you, and then solder it back onto the motherboard. *But don't run away scared just because you see a breadboard in a photo.* Look closer: the breadboard may be a part of the programmer and it still use a clip for the chip. The other end of the chip clip might be USB going into another computer. Maybe the other end goes into the same computer. Not all are USB. The contacts on Raspberry Pi Picos are also used as the other end.

### The comparision method ~ dump & flash
Generally, you compare to something you can control. If you already have a motherboard/computer you're not locked out of (at the firmware level) and the motherboard is the same model as your target machine's, great. Otherwise, you will probably need to get a replacement motherboard to make those comparisons (would you trust dumps you can get online?). Here we go:

1. If applicable, put the replacement motherboard in a computer other than the target machine so you don't have to keep swapping motherboards.
2. Dump the target machine's ROM chip to a file on another (or the same) computer. This will let you put things back if need be. If you want to be extra cautious, you can even make a backup of the chip on the comparison board at this point.
3. If the firmware version on the target machine (target motherboard, to be more specific) and on the replacement motherboard are not already the same, update them as needed to get them to the same version. We want to minimize differences.
4. If you updated the target machine's firmware, dump its ROM chip again. In this case, this is the "baseline" that you'll modify. Otherwise, the first dump from the target machine will serve as the baseline.
5. If not done already, set a password for the comparision machine's EFI, being careful not to loose this password. We'll compare this state to where the password is something else instead of comparing "no password" to "a password". "No password" might actually have more differences compared to "a password" if a boolean is set to false *and* the password (or hash) is cleared. We want to minimize differences.
6. Dump the ROM chip of the comparison machine.
7. Now change the EFI password to something else on the comparison machine.
8. Dump the ROM chip of the comparison machine again.
9. Use a tool like [utk][utk] to decompress the earlier of the last two dumps from the comparison machine. The extraction process will create a directroy structure of files. With utk, that command will look something like: `utk extract...`. BTW, `utk` uses the term "firmware volume" or "fv" to refer to a dump file, aka a "ROM file".
10. Initialize the resulting directory with git and commit everything. The `main` branch is your baseline. From the root of that directory:
    * `git init`
    * `git add --all`
    * `git commit -m 'Establish baseline'`
11. Delete everything out of the directory structure except for the (hidden) `.git` directory, which has a copy of what you're deleting.
12. Repeat the extraction process with the latter dump (made after setting the most recent password), saving to the same directory that we're using git with.
13. Run `git status` from the root of that directory to see which files changed.
14. Hopefully, only one file changed. Copy this file out somewhere, like your desktop.
15. Do `git checkout -b new_password` and `git add --all && git commit -m 'Change password'`. This saves the second state (dump) to a branch called `new_password`.
16. Do `git checkout main -- [path to changed file]` to get the previous version of the affected file(s). It/they will replace the newer file(s) "in place" (right there in the git-managed directory).
17. Assuming only one file changed, compare the file you just rolled back with the copy you saved elsewhere using a hex editor like HxD. Note the exact hexidecimal string and location of the difference. Don't be disappointed if you don't see your password in plain text: it's common practice to save a one-way hash of the password instead. Remember that you're changing *from* the old version in your git directory *to* the new version you copied out.
18. Extract the dump of your target machine somewhere. Again, use a tool like [utk][utk].
19. In that extraction, open the corresponding file of interest with a hex editor and overwrite (not insert) the discovered string at the exact same location. Nothing before or after the area changed should shift.
20. Repack that whole directory structure with a command like `utk save...`.
21. Flash this edited dump onto the target machine. Hopefully, the password is now the same as what you had set on your comparison machine (the second time).

[utk]: https://book.linuxboot.org/utilities/UEFI_Tool_Kit.html

### The lucky method üçÄ
If by incredible luck, you have [older machines that just so happen to be supported by Coreboot/Libreboot][libre-supported], you can replace the firmware entirely, which, obviously, will clear the password, but also does away with secure boot. Coreboot proper is source code only, so you'd have to build that one yourself. Libreboot is a pre-built distribution of Coreboot, but their list of supported hardware is longer, which is why I call it out here, though there are [other pre-built distributions][cb-distros]. Installation is as discussed before: with `flashprog` and with or without a chip programmer.
* I've read that [Libreboot does not support virtualization][libre-no-virt]. So if you want that, look into Heads, which is another distro of Coreboot. If you happen to have supported ThinkPads, Skulls may be an alternative to Heads. Failing those, you can compile Coreboot yourself.

[libre-supported]: https://libreboot.org/docs/install/#which-systems-are-supported-by-libreboot
[kernel-params]: https://libreboot.org/docs/install/devmem.html#devmem-access-error
[libre-no-virt]: https://www.reddit.com/r/linux4noobs/comments/ktzyv4/comment/gip3jwf/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
[programmers]: https://man.archlinux.org/man/flashprog.8.en#p,
[shell-spec]: https://uefi.org/sites/default/files/resources/UEFI_Shell_2_2.pdf
[tiano-shell]: https://github.com/tianocore/tianocore.github.io/wiki/Efi-shell
[wow]: https://www.reddit.com/r/homelab/comments/8x4qxq/how_i_cleared_an_unclearable_bios_password/
[cb-distros]: https://www.coreboot.org/end_users.html

### The crude method ~ dump & flash
Again, it is advisable to dump the target machine ROM before flashing so you can put things back.

You could just clone the ROM chip from an unlocked replacement board onto the target machine. However, this will likely result in the target machine reporting the same serial number as what the "source" motherboard reports. I don't know what other unintended side-effects there may be. Note that if the serial number is on a sticker or etched into the case, that won't match what's reported by software. At least that's what I would expect.

### Get creative! üé®
Don't feel limited by these options. Maybe you mix "a little of this with a little of that." Maybe you dump a ROM from an unlocked board, unpack it, edit the serial number to match the intended target, pack it back up, and flash that.
